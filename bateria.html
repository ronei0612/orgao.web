<!DOCTYPE html>
<html lang="pt-br">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Bateria Online</title>
    <link rel="stylesheet" href="https://stackpath.bootstrapcdn.com/bootstrap/4.5.2/css/bootstrap.min.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css"
          integrity="sha512-9usAa10IRO0HhonpyAIVpjrylPvoDwiPUiKdWk5t3PyolY1cOd4DSE0Ga+ri4AuTroPR5aQvXU9xC6qOPnzFeg=="
          crossorigin="anonymous" referrerpolicy="no-referrer" />
    <style>
        body {
            font-family: sans-serif;
            background-color: #f8f9fa;
        }

        .container {
            margin-top: 20px;
        }

        .controls {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
            align-items: center;
        }

        .track {
            display: flex;
            align-items: center;
            margin-bottom: 5px;
        }

            .track label {
                width: 120px;
                text-align: right;
                margin-right: 10px;
            }

        .step {
            width: 30px;
            height: 30px;
            border: 1px solid #ccc;
            margin-right: 5px;
            cursor: pointer;
            text-align: center;
            line-height: 30px;
        }

            .step.active {
                background-color: #198754;
                color: white;
            }

            .step.playing {
                background-color: #ffc107;
            }

            .step.active.playing {
                background-color: #28a745;
            }

        .rhythm-buttons {
            display: flex;
            gap: 10px;
            margin-bottom: 20px;
        }

            .rhythm-buttons button {
                width: 50px;
            }

                .rhythm-buttons button.selected {
                    background-color: #007bff;
                    color: white;
                }

        .rhythm-button.pending {
            animation: blinker 1s linear infinite;
        }

        .track label i {
            font-size: 1.5em; /* Ajuste o tamanho do ícone */
            margin-right: 5px; /* Adicione um espaço entre o ícone e os passos */
            vertical-align: middle; /* Alinhe verticalmente o ícone com os passos */
        }

        .step.low-volume {
            background-color: #8fbc8f; /* Cor verde mais clara para low volume */
            color: white;
        }

        @keyframes blinker {
            50% {
                opacity: 0;
            }
        }
    </style>
</head>

<body>
    <div class="container">
        <h1>Bateria Online</h1>

        <div class="rhythm-buttons">
            <button id="rhythm-a" class="btn btn-secondary rhythm-button">A</button>
            <button id="rhythm-b" class="btn btn-secondary rhythm-button">B</button>
            <button id="rhythm-c" class="btn btn-secondary rhythm-button">C</button>
            <button id="rhythm-d" class="btn btn-secondary rhythm-button">D</button>
            <button id="save-rhythm" class="btn btn-primary" style="width:auto">Salvar</button>
        </div>

        <div class="controls">
            <button id="play-pause" class="btn btn-success">Play</button>
            <input type="number" id="bpm" value="90" class="form-control" style="width: 70px;">
            <input type="number" id="num-steps" value="4" class="form-control" style="width: 70px;">
            <button id="clear" class="btn btn-danger">Limpar</button>
        </div>

        <div id="tracks">
        </div>

    </div>

    <script src="assets/js/DrumMachine.js"></script>
    <script>
        document.addEventListener('DOMContentLoaded', async () => {
            const drumMachine = new DrumMachine();
            await drumMachine.init();

            // Cache de elementos
            const playPauseButton = document.getElementById('play-pause');
            const bpmInput = document.getElementById('bpm');
            const clearButton = document.getElementById('clear');
            const tracksContainer = document.getElementById('tracks');
            const numStepsInput = document.getElementById('num-steps');
            const rhythmButtons = document.querySelectorAll('.rhythm-button');
            const saveRhythmButton = document.getElementById('save-rhythm');

            let selectedRhythm = 'A';
            let pendingRhythm = null;
            let pendingButton = null;

            // Delegação de eventos para steps
            tracksContainer.addEventListener('click', (event) => {
                if (event.target.classList.contains('step')) {
                    toggleStep(event.target);
                }
            });

            // Função para criar uma linha de instrumento usando DocumentFragment
            function createTrack(instrument) {
                const track = document.createElement('div');
                track.classList.add('track');

                const label = document.createElement('label');
                label.innerHTML = `${instrument.name} <i class="${instrument.icon}" title="${instrument.name}"></i>`;
                track.appendChild(label);

                const stepsFragment = document.createDocumentFragment();
                const currentSteps = parseInt(numStepsInput.value);
                for (let i = 1; i <= currentSteps; i++) {
                    const step = document.createElement('div');
                    step.classList.add('step');
                    step.textContent = i;
                    step.dataset.step = i;
                    step.dataset.volume = 0;
                    stepsFragment.appendChild(step);
                }
                track.appendChild(stepsFragment);
                return track;
            }

            // Inicializa as tracks usando DocumentFragment
            function initializeTracks() {
                const fragment = document.createDocumentFragment();
                drumMachine.instruments.forEach(inst => {
                    fragment.appendChild(createTrack(inst));
                });
                tracksContainer.innerHTML = '';
                tracksContainer.appendChild(fragment);
            }

            // Função para ativar/desativar um passo
            function toggleStep(step) {
                let volume = parseInt(step.dataset.volume);
                volume = (volume + 1) % 3;
                step.dataset.volume = volume;
                step.classList.remove('active', 'low-volume');
                if (volume === 1) {
                    step.classList.add('active');
                } else if (volume === 2) {
                    step.classList.add('low-volume');
                }
            }

            // Limpar todos os steps
            function clearSteps() {
                tracksContainer.querySelectorAll('.step').forEach(step => {
                    step.classList.remove('active', 'low-volume');
                    step.dataset.volume = 0;
                });
            }

            // Configurar callback para troca de ritmo
            drumMachine.onMeasureEnd = () => {
                if (pendingRhythm) {
                    loadRhythm(`rhythm-${pendingRhythm}`);
                    pendingRhythm = null;
                    if (pendingButton) {
                        pendingButton.classList.remove('pending');
                        pendingButton = null;
                    }
                }
            };

            // Função para iniciar/parar a reprodução
            function togglePlay() {
                if (!drumMachine.isPlaying) {
                    drumMachine.start();
                    playPauseButton.textContent = 'Stop';
                } else {
                    drumMachine.stop();
                    playPauseButton.textContent = 'Play';
                    // Retornar ao estado inicial visual
                    // Não há steps tocando, mas pode garantir que o passo inicial está pronto
                    // Se quiser, pode desmarcar todos os steps, mas normalmente só o currentStep volta ao início
                }
            }

            // Função para salvar o ritmo no localStorage
            function saveRhythm() {
                const rhythmData = {};
                tracksContainer.querySelectorAll('.track').forEach(track => {
                    const instrument = track.querySelector('label i').title.toLowerCase().replace(/ /g, '');
                    const stepsData = Array.from(track.querySelectorAll('.step')).map(step => parseInt(step.dataset.volume));
                    rhythmData[instrument] = stepsData;
                });
                localStorage.setItem(`rhythm-${selectedRhythm}`, JSON.stringify(rhythmData));
            }

            // Função para carregar o ritmo do localStorage
            function loadRhythm(rhythmKey) {
                const savedRhythm = localStorage.getItem(rhythmKey);
                if (savedRhythm) {
                    const rhythmData = JSON.parse(savedRhythm);
                    tracksContainer.querySelectorAll('.track').forEach(track => {
                        const instrument = track.querySelector('label i').title.toLowerCase().replace(/ /g, '');
                        const stepsData = rhythmData[instrument] || [];
                        track.querySelectorAll('.step').forEach((step, index) => {
                            const volume = stepsData[index] !== undefined ? stepsData[index] : 0;
                            step.dataset.volume = volume;
                            step.classList.remove('active', 'low-volume');
                            if (volume === 1) {
                                step.classList.add('active');
                            } else if (volume === 2) {
                                step.classList.add('low-volume');
                            }
                        });
                    });
                } else {
                    clearSteps();
                }
            }

            // Função para selecionar um botão de ritmo
            function selectRhythm(rhythmButton, rhythmKey) {
                if (pendingButton) {
                    pendingButton.classList.remove('pending');
                }
                rhythmButtons.forEach(button => button.classList.remove('selected'));
                rhythmButton.classList.add('selected');
                pendingRhythm = rhythmKey.replace('rhythm-', '').toUpperCase();
                selectedRhythm = pendingRhythm;
                rhythmButton.classList.add('pending');
                pendingButton = rhythmButton;
            }

            // Event listeners para os botões de ritmo
            document.getElementById('rhythm-a').addEventListener('click', () => selectRhythm(document.getElementById('rhythm-a'), 'rhythm-a'));
            document.getElementById('rhythm-b').addEventListener('click', () => selectRhythm(document.getElementById('rhythm-b'), 'rhythm-b'));
            document.getElementById('rhythm-c').addEventListener('click', () => selectRhythm(document.getElementById('rhythm-c'), 'rhythm-c'));
            document.getElementById('rhythm-d').addEventListener('click', () => selectRhythm(document.getElementById('rhythm-d'), 'rhythm-d'));

            saveRhythmButton.addEventListener('click', saveRhythm);
            playPauseButton.addEventListener('click', togglePlay);
            bpmInput.addEventListener('change', () => drumMachine.setBPM(parseInt(bpmInput.value)));
            clearButton.addEventListener('click', clearSteps);
            numStepsInput.addEventListener('change', () => {
                drumMachine.setNumSteps(parseInt(numStepsInput.value));
                initializeTracks();
            });

            // Carregar o ritmo selecionado ao carregar a página
            rhythmButtons.forEach(button => button.classList.remove('selected'));
            document.getElementById('rhythm-a').classList.add('selected');
            initializeTracks();
            loadRhythm('rhythm-A');
        });
    </script>
</body>

</html>