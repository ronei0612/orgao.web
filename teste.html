<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Web Audio - Acordes Otimizados com Master Gain</title>
    <style>
    </style>
</head>
<body>

    <h1>Controle de Acordes Otimizado</h1>

    <div class="button-group">
        <button id="playCButton" class="play-button" disabled>Play C</button>
        <button id="playGButton" class="play-button" disabled>Play G</button>
        <button id="stopButton" disabled>Stop</button>
    </div>

    <p id="statusMessage">Carregando recursos de áudio, por favor aguarde...</p>

    <script>
        // --- Configuração das URLs ---
        const audioConfigs = {
            'C': {
                urls: [
                    'https://roneicostasoares.com.br/orgao.web/assets/audio/Orgao/orgao_c.ogg', 'https://roneicostasoares.com.br/orgao.web/assets/audio/Orgao/orgao_e.ogg', 'https://roneicostasoares.com.br/orgao.web/assets/audio/Orgao/orgao_g.ogg', 'https://roneicostasoares.com.br/orgao.web/assets/audio/Orgao/orgao_c_grave.ogg', 'https://roneicostasoares.com.br/orgao.web/assets/audio/Orgao/orgao_e_grave.ogg', 'https://roneicostasoares.com.br/orgao.web/assets/audio/Orgao/orgao_g_grave.ogg', 'https://roneicostasoares.com.br/orgao.web/assets/audio/Orgao/orgao_c_baixo.ogg', 'https://roneicostasoares.com.br/orgao.web/assets/audio/Orgao/orgao_e_baixo.ogg', 'https://roneicostasoares.com.br/orgao.web/assets/audio/Orgao/orgao_g_baixo.ogg', 'https://roneicostasoares.com.br/orgao.web/assets/audio/Strings/strings_c.ogg', 'https://roneicostasoares.com.br/orgao.web/assets/audio/Strings/strings_e.ogg', 'https://roneicostasoares.com.br/orgao.web/assets/audio/Strings/strings_g.ogg', 'https://roneicostasoares.com.br/orgao.web/assets/audio/Strings/strings_c_grave.ogg', 'https://roneicostasoares.com.br/orgao.web/assets/audio/Strings/strings_e_grave.ogg', 'https://roneicostasoares.com.br/orgao.web/assets/audio/Strings/strings_g_grave.ogg', 'https://roneicostasoares.com.br/orgao.web/assets/audio/Strings/strings_c_baixo.ogg', 'https://roneicostasoares.com.br/orgao.web/assets/audio/Strings/strings_e_baixo.ogg', 'https://roneicostasoares.com.br/orgao.web/assets/audio/Strings/strings_g_baixo.ogg'
                ],
                buffers: [],
                sources: [] // Rastreamos apenas as SourceNodes para parada
            },
            'G': {
                urls: [
                    'https://roneicostasoares.com.br/orgao.web/assets/audio/Orgao/orgao_g.ogg', 'https://roneicostasoares.com.br/orgao.web/assets/audio/Orgao/orgao_b.ogg', 'https://roneicostasoares.com.br/orgao.web/assets/audio/Orgao/orgao_d.ogg', 'https://roneicostasoares.com.br/orgao.web/assets/audio/Orgao/orgao_g_grave.ogg', 'https://roneicostasoares.com.br/orgao.web/assets/audio/Orgao/orgao_b_grave.ogg', 'https://roneicostasoares.com.br/orgao.web/assets/audio/Orgao/orgao_d_grave.ogg', 'https://roneicostasoares.com.br/orgao.web/assets/audio/Orgao/orgao_g_baixo.ogg', 'https://roneicostasoares.com.br/orgao.web/assets/audio/Orgao/orgao_b_baixo.ogg', 'https://roneicostasoares.com.br/orgao.web/assets/audio/Orgao/orgao_d_baixo.ogg', 'https://roneicostasoares.com.br/orgao.web/assets/audio/Strings/strings_g.ogg', 'https://roneicostasoares.com.br/orgao.web/assets/audio/Strings/strings_b.ogg', 'https://roneicostasoares.com.br/orgao.web/assets/audio/Strings/strings_d.ogg', 'https://roneicostasoares.com.br/orgao.web/assets/audio/Strings/strings_g_grave.ogg', 'https://roneicostasoares.com.br/orgao.web/assets/audio/Strings/strings_b_grave.ogg', 'https://roneicostasoares.com.br/orgao.web/assets/audio/Strings/strings_d_grave.ogg', 'https://roneicostasoares.com.br/orgao.web/assets/audio/Strings/strings_g_baixo.ogg', 'https://roneicostasoares.com.br/orgao.web/assets/audio/Strings/strings_b_baixo.ogg', 'https://roneicostasoares.com.br/orgao.web/assets/audio/Strings/strings_d_baixo.ogg'
                ],
                buffers: [],
                sources: []
            }
        };

        const ATTACK_TIME = 0.3;
        const RELEASE_TIME = 0;
        const PEAK_VOLUME = 0.5;

        // --- Variáveis Globais ---
        let audioContext;
        let masterGainNode;
        let currentAcorde = null;

        // --- Elementos HTML ---
        const playCButton = document.getElementById('playCButton');
        const playGButton = document.getElementById('playGButton');
        const stopButton = document.getElementById('stopButton');
        const statusMessage = document.getElementById('statusMessage');
        const allPlayButtons = [playCButton, playGButton];

        const buttonMap = { 'playCButton': 'C', 'playGButton': 'G' };

        // Inicializa o AudioContext e o Master Gain Node
        function initializeContext() {
            if (!audioContext) {
                audioContext = new (window.AudioContext || window.webkitAudioContext)();
                // CRIA O NÓ DE GANHO MESTRE
                masterGainNode = audioContext.createGain();
                // CONECTA O NÓ MESTRE AO DESTINO FINAL
                masterGainNode.connect(audioContext.destination);
                // Inicializa o volume Mestre em 0 para garantir que nada toque antes do Play
                masterGainNode.gain.setValueAtTime(0, audioContext.currentTime);
            }
        }

        // Função assíncrona para carregar e decodificar um arquivo de áudio
        async function loadAudio(url) {
            try {
                const response = await fetch(url);
                const arrayBuffer = await response.arrayBuffer();
                if (!audioContext) initializeContext();
                return audioContext.decodeAudioData(arrayBuffer);
            } catch (error) {
                console.error(`Falha ao carregar ou decodificar: ${url}`, error);
                throw new Error(`Erro ao carregar o áudio de: ${url}`);
            }
        }

        // Função principal de pré-carregamento
        async function preloadAllAudio() {
            initializeContext();

            try {
                const allUrls = [...audioConfigs.C.urls, ...audioConfigs.G.urls];
                const loadingPromises = allUrls.map(url => loadAudio(url));
                const allBuffers = await Promise.all(loadingPromises);

                let bufferIndex = 0;
                for (const acorde in audioConfigs) {
                    const config = audioConfigs[acorde];
                    config.buffers = allBuffers.slice(bufferIndex, bufferIndex + config.urls.length);
                    bufferIndex += config.urls.length;
                }

                statusMessage.textContent = 'Carregamento concluído! Pronto para tocar.';
                updateButtonStates(null, false);

            } catch (error) {
                statusMessage.textContent = `Erro fatal no carregamento: ${error.message}. Recarregue a página.`;
                console.error(error);
            }
        }

        // Função para atualizar o estado visual dos botões
        function updateButtonStates(currentAcordeKey, isLoading = false) {
            allPlayButtons.forEach(button => {
                const acorde = buttonMap[button.id];

                // O botão só é desabilitado se estiver em estado de transição/carregamento
                const isDisabled = isLoading;

                button.disabled = isDisabled;
                button.classList.remove('active');

                if (isLoading) {
                    button.textContent = 'Transição...';
                } else if (acorde === currentAcordeKey) {
                    button.textContent = `Tocando ${acorde}...`;
                    button.classList.add('active');
                } else {
                    button.textContent = `Play ${acorde}`;
                }
            });
            stopButton.disabled = currentAcordeKey === null;
        }

        /**
         * Para o som atualmente tocando com um fade-out suave.
         * @returns {Promise<void>} - Resolve quando o fade-out estiver completo.
         */
        function stopCurrentSound() {
            return new Promise(resolve => {
                if (!currentAcorde) {
                    return resolve();
                }

                const config = audioConfigs[currentAcorde];
                const stopTime = audioContext.currentTime + RELEASE_TIME;

                // 1. APLICA O FADE-OUT NO NÓ DE GANHO MESTRE (Master Gain Node)
                masterGainNode.gain.cancelScheduledValues(audioContext.currentTime);
                masterGainNode.gain.linearRampToValueAtTime(0, stopTime);

                // 2. Agenda a parada das SourceNodes e a limpeza do estado após o fade-out
                setTimeout(() => {
                    // Pára todas as SourceNodes (importante para liberar recursos)
                    config.sources.forEach(source => {
                        try { source.stop(0); } catch (e) { /* ignore se já parou */ }
                    });
                    config.sources = []; // Limpa o array de sources
                    resolve();
                }, RELEASE_TIME * 1000);
            });
        }

        // Função principal para iniciar a reprodução
        async function startSound(acorde) {
            // Se o contexto estiver suspenso (por políticas de autoplay), tente resumir
            if (audioContext && audioContext.state === 'suspended') {
                audioContext.resume().catch(e => console.error("Falha ao resumir o AudioContext:", e));
            }

            if (acorde === currentAcorde) {
                return; // Já está tocando
            }

            // 1. Transição: Parar o som atual (com fade-out)
            const previousAcorde = currentAcorde;
            if (previousAcorde) {
                updateButtonStates(previousAcorde, true);
                statusMessage.textContent = `Transição: Parando Acorde ${previousAcorde}...`;
                // Espera o fade-out do acorde anterior
                await stopCurrentSound();
            }

            // 2. Iniciar o novo som
            currentAcorde = acorde;
            const config = audioConfigs[acorde];

            try {
                // Limpa e recria as SourceNodes (buffers já estão prontos)
                config.sources = [];

                config.buffers.forEach(buffer => {
                    const source = audioContext.createBufferSource();
                    source.buffer = buffer;
                    source.loop = true;

                    // Conecta a source DIRETAMENTE ao Master Gain Node
                    source.connect(masterGainNode);

                    // Inicia o áudio
                    source.start(0);

                    // Armazena a SourceNode
                    config.sources.push(source);
                });

                // --- Efeito Attack (Fade-in gradual) APLICADO NO MASTER GAIN NODE ---
                masterGainNode.gain.cancelScheduledValues(audioContext.currentTime); // Limpa agendamentos anteriores
                masterGainNode.gain.setValueAtTime(0, audioContext.currentTime);
                masterGainNode.gain.linearRampToValueAtTime(PEAK_VOLUME, audioContext.currentTime + ATTACK_TIME);


                // 3. Gerenciar botões e status após iniciar
                updateButtonStates(acorde, false);
                statusMessage.textContent = `Acorde de ${acorde} tocando em loop (Attack: ${ATTACK_TIME}s, Release: ${RELEASE_TIME}s).`;

            } catch (error) {
                // Em caso de erro
                console.error(error);
                updateButtonStates(null, false);
                statusMessage.textContent = `Erro durante a reprodução: ${error.message}`;
                currentAcorde = null;
            }
        }

        // Função do botão Stop (parada total)
        async function stopAll() {
            if (!currentAcorde) return;

            // 1. Feedback visual de parada
            allPlayButtons.forEach(btn => btn.disabled = true);
            stopButton.disabled = true;
            statusMessage.textContent = `Parando reprodução...`;

            // 2. Executa o fade-out
            await stopCurrentSound();

            // 3. Limpeza final e atualização do estado
            currentAcorde = null;
            updateButtonStates(null, false);
            statusMessage.textContent = 'Reprodução parada.';

            // Suspende o AudioContext para economizar recursos (opcional)
            if (audioContext && audioContext.state !== 'closed') {
                audioContext.suspend();
            }
        }

        // --- Listeners de Evento ---
        window.addEventListener('load', preloadAllAudio);

        playCButton.addEventListener('click', () => startSound('C'));
        playGButton.addEventListener('click', () => startSound('G'));
        stopButton.addEventListener('click', stopAll);

    </script>
</body>
</html>